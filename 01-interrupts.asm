k_rst00:
    di
    jp k_boot
    nop
    nop
    nop
    nop

k_rst08:
    di
    jp k_int_reti
    nop
    nop
    nop
    nop

k_rst10:
    di
    jp k_int_reti
    nop
    nop
    nop
    nop

k_rst18:
    di
    jp k_int_reti
    nop
    nop
    nop
    nop

k_rst20:
    di
    jp k_int_reti
    nop
    nop
    nop
    nop

k_rst28:
    di
    jp k_int_reti
    nop
    nop
    nop
    nop

k_rst30:
    di
    jp k_int_reti
    nop
    nop
    nop
    nop

k_rst38:
    di
    jp k_int_key
    nop
    nop
    nop
    nop

k_int_reti:
    ei                          ; enable interrupts
    reti                        ; return from interrupt

k_boot_msg:
    defb "oz 0.0\n", 0

; Called at boot time to initialize the system
;
k_boot:
    im 1                        ; INTERRUPT MODE 1 (rst38)
    ld sp, 0x7fff               ; set the kernel stack top
    ld (k_sp_kernel), sp        ; store the kernel stack top variable
    call sio_channel_a_init     ; init the A channel of the SIO
    ld a, 0x00                  ; prepare to set k_serbuf_read
    ld (k_serbuf_read), a       ; set k_serbuf_read to zero
    ld a, 0x00                  ; prepare to set k_serbuf_write
    ld (k_serbuf_write), a      ; set k_serbuf_write to zero
    call k_boot_sysinfo         ; print system info
    ei
k_boot_main:
    nop                         ; this is what the kernel will do until interrupt
    jp k_boot_main              ; enter an infinite loop

; Print system information to the serial console
;
k_boot_sysinfo:
    ld hl, k_boot_msg           ; prepare to print first line
    call k_print_string         ; call print routine
    ret

; Print a null terminated string from a memory location in hl to the serial console
;
k_print_string:
    ld a, (hl)                  ; load the first char into a
    cp 0x00                     ; check if zero
    jr z, k_print_end           ; return if null terminator
    out (sioa_d), a             ; print the char
    inc hl                      ; move to next char
    jr k_print_string           ; print next char
k_print_end:
    ret

; Called from the interrupt generated by the SIO on a key press
;
k_int_key:
    ex af, af'                  ; exchange part 1
    exx                         ; exchange part 2
    call k_serial_read          ; call routine to read the serial port
    exx                         ; exchange part 2
    ex af, af'                  ; exchange part 1
    jp k_int_reti               ; jump to return

; Read available bytes from the SIO into a ring buffer
;
k_serial_read:
    in a, (sioa_c)              ; read the status register
    bit 0, a                    ; test the char ready bit
    jr z, k_serial_read_end     ; if no char abort
    ld a, (k_serbuf_read)       ; load the serial read pointer
    ld b, a                     ; move it to b
    ld a, (k_serbuf_write)      ; load the serial write pointer
    inc a                       ; advance the copy of write pointer
    sub b                       ; subtract to test equality
    jr z, k_serial_read_end     ; if read and write are equal abort
    ld (k_serbuf_write), a      ; store advanced write pointer
    ld hl, k_serbuf_base        ; load the ring buffer base address
    ld d, 0x00                  ; zero high byte of de
    ld e, a                     ; load e with incremented write
    add hl, de                  ; add write pointer to base
    ex de, hl                   ; put computed hl into de
    in a, (sioa_d)              ; read the character
    ld (de), a                  ; store the char into buffer
    out (sioa_d), a             ; echo the character
    jp k_serial_read            ; continue to read until empty
k_serial_read_end:
    ret
