# oz-rc2014

Playing with operating system ideas for the RC2014 computer.

* No preemptive multitasking (no interrupt via CTC hardware)
* No process model - the function is the unit of execution

Applications are collections of functions, combined with an environment. The environment is a stack, saved registers and some heap. Applications do work by registering callback functions to event queues (producers and consumers). Some event queues are provided by the operating system, some provided by other applications.

There is no concept of process or thread, only different configurations of stack pointer, heap location and functions - chunks of code that are called and return, without entering into any form of event loop. The only event loop is the kernel performing dispatch on the event queues.

## The System

The system is made up of the following components:

* Data queues
* Environments
* Functions (producers or consumers)
* Kernel event loop

Functions are executed as producers or consumers of data queues. Producers are expected to write data to a queue, consumers are expected to read data from a queue and do something with it. Each function is executed in an environment. The environment is chunk of memory consisting of a heap and a stack top. The kernel event loop cycles over all active queues and executes the producer and consumer functions on them. All functions are executed without interrupt or context switching.

### Data queues

These are circular buffers with a read and write head. Producer functions are always called on an active queue. Consumer functions are only called if there is something in the buffer to be read.

### Environments

Each function is called with an environment loaded. The environment is the location of the stack pointer and the location of the heap. Functions that execute with an independent stack pointer but a shared heap behave in a similar way to threads. However there is no memory locking required as only one function can execute at a time. The state of registers is not saved when there is an environment switch because it is assumed that functions will not store state in registers between invocations. Any state saved between invocations must be stored in heap memory or on the stack.

### Functions

Functions are either producers or consumers of data. They will make calls back into kernel code to push items onto a queue, pop items from a queue or create and destroy queues. Consumers may use their environment heap to update some state based on data read from a queue. Producers may use heap data to generate new data for other queues, or even poll hardware to generate queue data.

### Kernel event loop

The main purpose of the kernel event loop is to call producer and consumer functions. The loop simply interates over all the active queues and calles their associated functions.

## General operation

The kernel event loop dispatches to the producer then the consumer functions attached to that queue. The producer will call a routine in ROM code to add data to the active queue. This call passes an address of a buffer from which to get the data and a length parameter of how many bytes to copy from that buffer to the queue. If the queue would overflow from the write it is rejected. Likewise a consumer also calls a ROM routine to read data from the queue into a destination buffer with a maximum number of bytes. As the buffer may have less data than what was asked for this routine returns the number of bytes actually read into the buffer.

## Differences from preemptive multitasking

In a process or thread orientated operating system each thread will probably have it's own event loop - the operating system will interrupt and share CPU time between the threads meaning they must use some form or locking when accessing heap memory because each thread might get interrupted while it's in the middle of a critical section. This is not needed for OZ because there are no context switches and functions are not interrupted mid-execution to be swapped for other functions.

There is one exception to this and that is the interrupt generated by data received from the serial console. This raises a hardware interrupt, however the interrupt code uses the shadow registers to temporarily switch context and save the received characters.

### How do applications get launched and stopped

The concept of...

# Building

* Get [z80asm](http://download.savannah.nongnu.org/releases/z80asm/) from GNU. Compile the binary, rename it to `z80asm-gnu` and put it in the PATH.
* Run `git submodule update --init --recursive` to populate `z8t` submodule.
* Change into `z8t/` directory and `git submodule update --init --recursive` to pull the `z80ex` library.
* Run `make` in the `z8t/` directory to build `z80ex/z80ex.o` and the `z8t` binary.

Once `z80asm-gnu` and `z8t` are compiled the tests can be run. Chnge into the `t/` directory and type `make`.
